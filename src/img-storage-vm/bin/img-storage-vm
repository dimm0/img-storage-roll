#!/opt/rocks/bin/python
#
# @Copyright@
#
# 				Rocks(r)
# 		         www.rocksclusters.org
# 		         version 5.6 (Emerald Boa)
# 		         version 6.1 (Emerald Boa)
#
# Copyright (c) 2000 - 2013 The Regents of the University of California.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
# notice unmodified and in its entirety, this list of conditions and the
# following disclaimer in the documentation and/or other materials provided
# with the distribution.
#
# 3. All advertising and press materials, printed or electronic, mentioning
# features or use of this software must display the following acknowledgement:
#
# 	"This product includes software developed by the Rocks(r)
# 	Cluster Group at the San Diego Supercomputer Center at the
# 	University of California, San Diego and its contributors."
#
# 4. Except as permitted for the purposes of acknowledgment in paragraph 3,
# neither the name or logo of this software nor the names of its
# authors may be used to endorse or promote products derived from this
# software without specific prior written permission.  The name of the
# software includes the following terms, and any derivatives thereof:
# "Rocks", "Rocks Clusters", and "Avalanche Installer".  For licensing of
# the associated name, interested parties should contact Technology
# Transfer & Intellectual Property Services, University of California,
# San Diego, 9500 Gilman Drive, Mail Code 0910, La Jolla, CA 92093-0910,
# Ph: (858) 534-5815, FAX: (858) 534-7345, E-MAIL:invent@ucsd.edu
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# @Copyright@
#
from rabbit_client.RabbitMQClient import RabbitMQPublisher, RabbitMQConsumer
import logging

from threading import Thread

from daemon import runner
import subprocess
import time
import json
import random
import re
NODE_NAME = 'compute-0-2' # this node's name
import signal
RABBITMQ_SERVER = 'localhost'

try:
    import rocks.db.helper

    db = rocks.db.helper.DatabaseHelper()
    db.connect()
    RABBITMQ_SERVER = db.getHostAttr(db.getHostname('localhost'), 'Kickstart_PrivateHostname')
    db.close()
except ImportError:
    pass

RABBITMQ_URL = 'amqp://guest:guest@%s:5672/%%2F?connection_attempts=3&heartbeat_interval=3600'%RABBITMQ_SERVER

class RabbitClientDaemonVm():

    def __init__(self):
        self.stdin_path = '/dev/null'
        self.stdout_path = '/dev/null'
        self.stderr_path = '/dev/null'
        self.pidfile_path =  '/var/run/imgstoragedaemon.pid'
        self.pidfile_timeout = 5
        self.function_dict = {'set_zvol':self.set_zvol, 'tear_down':self.tear_down }
	self.stoping = False

    """
    Received set_zvol command from nas
    """
    def set_zvol(self, message, props):
        logger.debug("Setting zvol %s"%message['target'])
	if(self.connect_iscsi(message['target'], props.reply_to)):
		bdev = self.get_blk_dev(message['target'])
		if(bdev is None):
		    pass # TODO send error
		else:
		    self.vmPublisher.messages.put({'message': {'action': 'zvol_attached', 'target':message['target'], 'bdev':bdev}, 'routing_key': props.reply_to})

    def get_blk_dev(self, iscsi_target):
        cmd = subprocess.Popen(['iscsiadm', '-m', 'session', '-P3'], stdout=subprocess.PIPE)
        parsing_target = False
        for line in cmd.stdout:
                if "Target: %s"%iscsi_target in line:
                        parsing_target = True
                if parsing_target and ('Attached scsi disk ' in line):
                        searchObj = re.search( r'Attached scsi disk (\w*)', line, re.M)
                        if searchObj:
                            return searchObj.group(1)
        return None

    def connect_iscsi(self, iscsi_target, node_name):
	cmd = subprocess.Popen(['iscsiadm', '--mode', 'discovery', '--type', 'sendtargets', '-p', node_name], stdout=subprocess.PIPE)
	for line in cmd.stdout:
		if iscsi_target in line: #has the target
		        return subprocess.call(['iscsiadm', '-m', 'node', '-T', iscsi_target, '-p', node_name, '-l']) == 0
	return False

    def disconnect_iscsi(self, iscsi_target):
	return subprocess.call(['iscsiadm', '-m', 'node', '-T', iscsi_target, '-u']) == 0

    """
    Received zvol tear_down command from nas
    """
    def tear_down(self, message, props):
        logger.debug("Tearing down zvol %s"%message['target'])
	if(self.disconnect_iscsi(message['target'])):
        	self.vmPublisher.messages.put({'message': {'action': 'zvol_detached', 'target':message['target']}, 'routing_key': props.reply_to})

    def process_message(self, properties, message):
        logger.debug("Received message %s"%message)
        self.function_dict[message['action']](message, properties)

    def run(self):
        # Connect to localhost:5672 as guest with the password guest and virtual host "/" (%2F)
        self.vmPublisher = RabbitMQPublisher(RABBITMQ_URL, 'rocks.vm-manage', 'direct')

        t_publish = Thread(target=self.vmPublisher.run)
        t_publish.start()
        logger.debug('started publisher')

        self.vmConsumer = RabbitMQConsumer(RABBITMQ_URL, 'rocks.vm-manage', 'direct', NODE_NAME, self.process_message)

        t_consume = Thread(target=self.vmConsumer.run)
        t_consume.start()
        logger.debug('started consumer')

        while(not(self.stoping)):
                time.sleep(1)
        #t_publish.join()
        #t_consume.join()
	

    def stop(self):
        self.vmConsumer.stop()
        self.vmPublisher.stop()
	self.stoping = True
        logger.info('Consumer and publisher stopping called')


logger = logging.getLogger("DaemonLog")
logger.setLevel(logging.DEBUG)
formatter = logging.Formatter("'%(levelname) -10s %(asctime)s %(name) -30s %(funcName) -35s %(lineno) -5d: %(message)s'")
handler = logging.FileHandler("/var/log/rocks/img-storage-vm.log")
handler.setFormatter(formatter)
logger.addHandler(handler)
logging.getLogger("pika.channel").setLevel(logging.INFO)
logging.getLogger("pika.channel").addHandler(handler)
logging.getLogger("pika.connection").setLevel(logging.INFO)
logging.getLogger("pika.connection").addHandler(handler)
logging.getLogger("rabbit_client.RabbitMQClient").setLevel(logging.DEBUG)
logging.getLogger("rabbit_client.RabbitMQClient").addHandler(handler)


app = RabbitClientDaemonVm()
daemon_runner = runner.DaemonRunner(app)

#This ensures that the logger file handle does not get closed during daemonization
daemon_runner.daemon_context.files_preserve=[handler.stream]
daemon_runner.daemon_context.signal_map = {signal.SIGTERM: lambda signum, frame: app.stop()}

daemon_runner.do_action()
